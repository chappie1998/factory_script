{"version":3,"sources":["../src/index.ts","../src/common.ts","../src/codegen/functions.ts","../src/utils.ts","../src/codegen/types.ts","../src/codegen/reserved-keywords.ts","../src/codegen/structs.ts","../src/codegen/index.ts","../src/parser/parseSvmTypes.ts","../src/parser/abiParser.ts"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\nimport { readFileSync } from 'fs';\nimport { join, resolve } from 'path';\nimport type { Dictionary } from 'ts-essentials';\nimport type { CodegenConfig, Config, FileDescription } from 'typechain';\nimport { getFilename, TypeChainTarget } from 'typechain';\n\nimport { codegenAbstractContractFactory, codegenContractTypings } from './codegen';\nimport { FACTORY_POSTFIX } from './common';\nimport { extractAbi, extractDocumentation, parse } from './parser/abiParser';\nimport type { Contract, RawAbiDefinition } from './parser/abiParser';\nimport { normalizeName } from './parser/parseSvmTypes';\n\nconst DEFAULT_OUT_PATH = './types/fuels-contracts/';\n\nexport default class Fuels extends TypeChainTarget {\n  name = 'Fuels';\n\n  private readonly allContracts: string[];\n  private readonly outDirAbs: string;\n  private readonly contractCache: Dictionary<\n    | {\n        abi: RawAbiDefinition[];\n        contract: Contract;\n      }\n    | undefined\n  > = {};\n\n  constructor(config: Config) {\n    super(config);\n\n    const { cwd, outDir, allFiles } = config;\n\n    this.outDirAbs = resolve(cwd, outDir || DEFAULT_OUT_PATH);\n\n    this.allContracts = allFiles.map((fp) => normalizeName(getFilename(fp)));\n  }\n\n  transformFile(file: FileDescription): FileDescription[] | void {\n    const name = getFilename(file.path);\n    const abi = extractAbi(file.contents);\n\n    if (abi.length === 0) {\n      return undefined;\n    }\n\n    const documentation = extractDocumentation(file.contents);\n    const contract = parse(abi, name, documentation);\n\n    this.contractCache[name] = { abi, contract };\n    return [this.genContractTypingsFile(contract, this.cfg.flags)];\n  }\n\n  genContractTypingsFile(contract: Contract, codegenConfig: CodegenConfig): FileDescription {\n    return {\n      path: join(this.outDirAbs, `${contract.name}.d.ts`),\n      contents: codegenContractTypings(contract, codegenConfig),\n    };\n  }\n\n  afterRun(): FileDescription[] {\n    // For each contract that doesn't have bytecode (it's either abstract, or only ABI was provided)\n    // generate a simplified factory, that allows to interact with deployed contract instances.\n    const abstractFactoryFiles = Object.keys(this.contractCache).map((contractName) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const { contract, abi } = this.contractCache[contractName]!;\n      return {\n        path: join(this.outDirAbs, 'factories', `${contract.name}${FACTORY_POSTFIX}.ts`),\n        contents: codegenAbstractContractFactory(contract, abi),\n      };\n    });\n\n    const allFiles = [\n      ...abstractFactoryFiles,\n      {\n        path: join(this.outDirAbs, 'common.d.ts'),\n        contents: readFileSync(join(__dirname, '../static/common.d.ts'), 'utf-8'),\n      },\n      {\n        path: join(this.outDirAbs, 'index.ts'),\n        contents: this.genReExports(),\n      },\n    ].filter(Boolean);\n    return allFiles;\n  }\n\n  private genReExports(): string {\n    const codegen: string[] = [];\n\n    const allContractsNoDuplicates = new Set(this.allContracts);\n\n    for (const fileName of allContractsNoDuplicates) {\n      const desiredSymbol = fileName;\n\n      codegen.push(`export type { ${desiredSymbol} } from './${desiredSymbol}'`);\n    }\n\n    codegen.push('\\n');\n\n    // then generate reexports for TypeChain generated factories\n    for (const fileName of allContractsNoDuplicates) {\n      const desiredSymbol = `${fileName}__factory`;\n\n      codegen.push(`export { ${desiredSymbol} } from './factories/${desiredSymbol}'`);\n    }\n\n    return codegen.join('\\n');\n  }\n}\n","export const FACTORY_POSTFIX = '__factory';\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { CodegenConfig } from 'typechain';\nimport { createPositionalIdentifier } from 'typechain';\n\nimport type { AbiParameter, FunctionDeclaration, FunctionDocumentation } from '../parser/abiParser';\nimport { getSignatureForFn } from '../utils';\n\nimport { generateInputType, generateInputTypes, generateOutputTypes } from './types';\n\ninterface GenerateFunctionOptions {\n  returnResultObject?: string;\n  isStaticCall?: boolean;\n  overrideOutput?: string;\n  codegenConfig: CodegenConfig;\n  isPrepareCall?: boolean;\n}\n\n/**\n * Generate functions and overloaded functions for the target abi\n */\nexport function codegenFunctions(\n  options: GenerateFunctionOptions,\n  fns: FunctionDeclaration[]\n): string {\n  if (fns.length === 1) {\n    return generateFunction(options, fns[0]);\n  }\n\n  return codegenForOverloadedFunctions(options, fns);\n}\n\n/**\n * Generate overloaded functions for the target abi\n */\nexport function codegenForOverloadedFunctions(\n  options: GenerateFunctionOptions,\n  fns: FunctionDeclaration[]\n): string {\n  return fns.map((fn) => generateFunction(options, fn, `\"${getSignatureForFn(fn)}\"`)).join('\\n');\n}\n\n/**\n * Generate function, docs and returns types for the target abi\n */\nfunction generateFunction(\n  options: GenerateFunctionOptions,\n  fn: FunctionDeclaration,\n  overloadedName?: string\n): string {\n  let prependedArg;\n  let returnType;\n  if (options.isPrepareCall) {\n    prependedArg = 'options?: ContractCallOptions';\n    returnType = 'ContractCall';\n  } else {\n    prependedArg = `overrides?: ${'Overrides & { from?: string | Promise<string> }'}`;\n    returnType = `Promise<${generateOutputTypes(fn.outputs, {\n      returnResultObject: options.returnResultObject,\n      useStructs: true,\n    })}>`;\n  }\n  return `\n  ${generateFunctionDocumentation(fn.documentation)}\n  ${overloadedName ?? fn.name}(${generateInputTypes(fn.inputs, {\n    useStructs: true,\n  })}${prependedArg}): ${returnType};\n`;\n}\n\n/**\n * Generate function documentation\n */\nfunction generateFunctionDocumentation(doc?: FunctionDocumentation): string {\n  if (!doc) return '';\n\n  let docString = '/**';\n  if (doc.details) docString += `\\n * ${doc.details}`;\n  if (doc.notice) docString += `\\n * ${doc.notice}`;\n\n  const params = Object.entries(doc.params || {});\n  if (params.length) {\n    params.forEach(([key, value]) => {\n      docString += `\\n * @param ${key} ${value}`;\n    });\n  }\n\n  if (doc.return) docString += `\\n * @returns ${doc.return}`;\n\n  docString += '\\n */';\n\n  return docString;\n}\n\n/**\n * Generate function interface\n */\nexport function generateInterfaceFunctionDescription(fn: FunctionDeclaration): string {\n  return `'${fn.name}': FunctionFragment;`;\n}\n\n/**\n * Generate abi encode function for target\n */\nexport function generateEncodeFunctionDataOverload(fn: FunctionDeclaration): string {\n  const methodInputs = [`functionFragment: '${fn.name}'`];\n\n  if (fn.inputs.length) {\n    methodInputs.push(\n      `values: [${fn.inputs\n        .map((input) => generateInputType(input.type, { useStructs: true }))\n        .join(', ')}]`\n    );\n  } else {\n    methodInputs.push('values?: undefined');\n  }\n\n  return `encodeFunctionData(${methodInputs.join(', ')}): Uint8Array;`;\n}\n\n/**\n * Generate abi decode function for target\n */\nexport function generateDecodeFunctionDataOverload(fn: FunctionDeclaration): string {\n  return `decodeFunctionData(functionFragment: '${fn.name}', data: BytesLike): DecodedValue;`;\n}\n\n/**\n * Generate param names for abi target\n */\nexport function generateParamNames(params: Array<AbiParameter>): string {\n  return params\n    .map((param, index) => (param.name ? createPositionalIdentifier(param.name) : `arg${index}`))\n    .join(', ');\n}\n","import type { AbiParameter, FunctionDeclaration } from './parser/abiParser';\nimport type { TupleType } from './parser/parseSvmTypes';\n\n/**\n * Generate signature for abi tuple\n */\nexport function getArgumentForSignature(argument: AbiParameter): string {\n  if (argument.type.originalType !== 'tuple') return argument.type.originalType;\n  return `(${(argument.type as TupleType).components\n    .map((i) => getArgumentForSignature(i))\n    .join(',')})`;\n}\n\n/**\n * Generate signature for functions both primative and non-primative types\n */\nexport function getSignatureForFn(fn: FunctionDeclaration): string {\n  return `${fn.name}(${fn.inputs.map((i) => getArgumentForSignature(i)).join(',')})`;\n}\n","/* eslint-disable @typescript-eslint/no-shadow */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { AbiOutputParameter, AbiParameter } from '../parser/abiParser';\nimport type {\n  EnumType,\n  StructType,\n  SvmOutputType,\n  SvmType,\n  TupleType,\n} from '../parser/parseSvmTypes';\n\ninterface GenerateTypeOptions {\n  returnResultObject?: string;\n  useStructs?: boolean; // uses struct type for first depth, if false then generates first depth tuple types\n}\n\n/**\n * Generates the Typescript types for given function\n */\nexport function generateInputTypes(\n  input: Array<AbiParameter>,\n  options: GenerateTypeOptions\n): string {\n  if (input.length === 0) {\n    return '';\n  }\n\n  return `${input\n    .map(\n      (input, index) => `${input.name || `arg${index}`}: ${generateInputType(input.type, options)}`\n    )\n    .join(', ')}, `;\n}\n\n/**\n * Generates the Typescript types for given function\n */\nexport function generateOutputTypes(\n  output: Array<AbiOutputParameter>,\n  options: GenerateTypeOptions = {}\n): string {\n  if (output.length === 0) {\n    // If return result object exists them\n    // return it instead of void\n    if (options.returnResultObject) {\n      return options.returnResultObject;\n    }\n    return 'void';\n  }\n\n  const outputs = output.map((output) => generateOutputType(output.type, options));\n\n  if (outputs.length > 1) {\n    return `[${outputs.join(',')}]`;\n  }\n\n  return outputs[0];\n}\n\n/**\n * Maps Input SvmTypes to TS types\n * https://docs.ethers.io/ethers.js/html/api-contract.html#types\n */\nexport function generateInputType(svmType: SvmType, options: GenerateTypeOptions = {}): string {\n  switch (svmType.type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n      return 'BigNumberish';\n    case 'b256':\n    case 'address':\n      return 'string';\n    case 'byte':\n      return 'BytesLike';\n    case 'array':\n      return `[${Array(svmType.size)\n        .fill(generateInputType(svmType.itemType, { useStructs: true }))\n        .join(', ')}]`;\n    case 'bool':\n      return 'boolean';\n    case 'string':\n      return 'string';\n    case 'tuple':\n      return generateTupleType(svmType, (svmType) =>\n        generateInputType(svmType, { ...options, useStructs: true })\n      );\n    case 'enum':\n      if (svmType.structName && options.useStructs) {\n        return `${svmType.structName}Input`;\n      }\n      return generateEnumType(svmType, (svmType) =>\n        generateInputType(svmType, { ...options, useStructs: true })\n      );\n    case 'struct':\n      if (svmType.structName && options.useStructs) {\n        return `${svmType.structName}Input`;\n      }\n      return generateStructType(svmType, (svmType) =>\n        generateInputType(svmType, { ...options, useStructs: true })\n      );\n    case 'unknown':\n      return 'any';\n    default:\n      return 'any';\n  }\n}\n\n/**\n * Maps Output SvmTypes to TS types\n * https://docs.ethers.io/ethers.js/html/api-contract.html#types\n */\nexport function generateOutputType(\n  svmType: SvmOutputType,\n  options: GenerateTypeOptions = {}\n): string {\n  if (options.returnResultObject) {\n    return options.returnResultObject;\n  }\n\n  switch (svmType.type) {\n    case 'u8':\n    case 'u16':\n      return 'number';\n    case 'u32':\n    case 'u64':\n      return 'bigint';\n    case 'b256':\n    case 'address':\n      return 'string';\n    case 'byte':\n      return 'BytesLike';\n    case 'array':\n      return `[${Array(svmType.size)\n        .fill(generateOutputType(svmType.itemType, { useStructs: true }))\n        .join(', ')}]`;\n    case 'bool':\n      return 'boolean';\n    case 'string':\n      return 'string';\n    case 'tuple':\n      return generateTupleType(svmType, (svmType) =>\n        generateOutputType(svmType, { ...options, useStructs: true })\n      );\n    case 'enum':\n      if (svmType.structName && options.useStructs) {\n        return `${svmType.structName}Output`;\n      }\n      return generateEnumType(svmType, (svmType) =>\n        generateOutputType(svmType, { ...options, useStructs: true })\n      );\n    case 'struct':\n      if (svmType.structName && options.useStructs) {\n        return `${svmType.structName}Output`;\n      }\n      return generateStructType(svmType, (svmType) =>\n        generateOutputType(svmType, { ...options, useStructs: true })\n      );\n    case 'unknown':\n      return 'any';\n    case 'void':\n      return 'void';\n    default:\n      return 'any';\n  }\n}\n\nexport function generateTupleType(\n  tuple: TupleType,\n  generator: (svmType: SvmType) => string\n): string {\n  return `[${tuple.components.map((component) => generator(component.type)).join(', ')}]`;\n}\n\nexport function generateStructType(\n  struct: StructType,\n  generator: (svmType: SvmType) => string\n): string {\n  return `{${struct.components\n    .map((component) => `${component.name}: ${generator(component.type)}`)\n    .join(', ')}}`;\n}\n\nexport function generateEnumType(_enum: EnumType, generator: (svmType: SvmType) => string): string {\n  return `Partial<{${_enum.components\n    .map((component) => `${component.name}: ${generator(component.type)}`)\n    .join(', ')}}>`;\n}\n","export const reservedKeywords = new Set([\n  'signer',\n  'provider',\n  'deployTransaction',\n  'deployed',\n  'fallback',\n  'connect',\n]);\n","import type { DatumType } from '../parser/parseSvmTypes';\n\nimport { generateInputType, generateOutputType } from './types';\n\n/**\n * Generates TS structs for ABI target\n */\nexport default function generateStruct(datum: DatumType): string {\n  if (datum.structName) {\n    return `\n      export type ${datum.structName}Input = ${generateInputType(datum, {\n      useStructs: false,\n    })}\n\n      export type ${datum.structName}Output = ${generateOutputType(datum, {\n      useStructs: false,\n    })}\n      `;\n  }\n  return '';\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { CodegenConfig } from 'typechain';\n\nimport { FACTORY_POSTFIX } from '../common';\nimport type { Contract, RawAbiDefinition } from '../parser/abiParser';\n\nimport {\n  codegenFunctions,\n  generateDecodeFunctionDataOverload,\n  generateEncodeFunctionDataOverload,\n  generateInterfaceFunctionDescription,\n} from './functions';\nimport { reservedKeywords } from './reserved-keywords';\nimport generateStruct from './structs';\n\n/**\n * Generate the contract as TS code\n */\nexport function codegenContractTypings(contract: Contract, codegenConfig: CodegenConfig): string {\n  const template = `\n  import type {\n    Interface,\n    FunctionFragment,\n    DecodedValue,\n    Contract,\n    ContractCall,\n    ContractCallOptions,\n    Overrides,\n    BigNumberish,\n    BytesLike,\n    CallResult,\n    ScriptTransactionRequest,\n    TransactionResult,\n  } from 'fuels';\n  \n  ${Object.values(contract.structs)\n    .map((v) => generateStruct(v[0]))\n    .join('\\n')}\n  \n  ${Object.values(contract.enums)\n    .map((v) => generateStruct(v[0]))\n    .join('\\n')}\n\n  interface ${contract.name}Interface extends Interface {\n    functions: {\n      ${Object.values(contract.functions)\n        .map((v) => v[0])\n        .map(generateInterfaceFunctionDescription)\n        .join('\\n')}\n    };\n\n    ${Object.values(contract.functions)\n      .map((v) => v[0])\n      .map(generateEncodeFunctionDataOverload)\n      .join('\\n')}\n\n    ${Object.values(contract.functions)\n      .map((v) => v[0])\n      .map(generateDecodeFunctionDataOverload)\n      .join('\\n')}\n  }\n\n  export class ${contract.name} extends Contract {\n    interface: ${contract.name}Interface;\n    prepareCall: {\n      ${Object.values(contract.functions)\n        .map(\n          codegenFunctions.bind(null, {\n            isPrepareCall: true,\n            codegenConfig,\n          })\n        )\n        .join('\\n')}\n    };\n    submit: {\n      ${Object.values(contract.functions)\n        .map(codegenFunctions.bind(null, { returnResultObject: undefined, codegenConfig }))\n        .join('\\n')}\n    };\n    submitResult: {\n      ${Object.values(contract.functions)\n        .map(\n          codegenFunctions.bind(null, {\n            returnResultObject: 'TransactionResult<any>',\n            codegenConfig,\n          })\n        )\n        .join('\\n')}\n    };\n    dryRun: {\n      ${Object.values(contract.functions)\n        .map(codegenFunctions.bind(null, { returnResultObject: undefined, codegenConfig }))\n        .join('\\n')}\n    };\n    dryRunResult: {\n      ${Object.values(contract.functions)\n        .map(codegenFunctions.bind(null, { returnResultObject: 'CallResult', codegenConfig }))\n        .join('\\n')}\n    };\n    simulate: {\n      ${Object.values(contract.functions)\n        .map(codegenFunctions.bind(null, { returnResultObject: undefined, codegenConfig }))\n        .join('\\n')}\n    };\n    simulateResult: {\n      ${Object.values(contract.functions)\n        .map(codegenFunctions.bind(null, { returnResultObject: 'CallResult', codegenConfig }))\n        .join('\\n')}\n    };\n\n    ${Object.values(contract.functions)\n      .filter((f) => !reservedKeywords.has(f[0].name))\n      .map(codegenFunctions.bind(null, { codegenConfig }))\n      .join('\\n')}\n  }`;\n\n  return template;\n}\n\n/**\n * Generate the contract factory as TS code\n */\nexport function codegenAbstractContractFactory(\n  contract: Contract,\n  abi: RawAbiDefinition[]\n): string {\n  const { body, header } = codegenCommonContractFactory(contract, abi);\n  return `\n  ${header}\n\n  export class ${contract.name}${FACTORY_POSTFIX} {\n    ${body}\n  }\n  `;\n}\n\n/**\n * Generate the common contract factory as TS code\n */\nfunction codegenCommonContractFactory(\n  contract: Contract,\n  abi: RawAbiDefinition[]\n): { header: string; body: string } {\n  const header = `\n  import type { Provider, Wallet } from \"fuels\";\n  import { Interface, Contract } from \"fuels\";\n  import type { ${contract.name}, ${contract.name}Interface } from \"../${contract.name}\";\n  const _abi = ${JSON.stringify(abi, null, 2)};\n  `.trim();\n\n  const body = `\n    static readonly abi = _abi;\n    static createInterface(): ${contract.name}Interface {\n      return new Interface(_abi) as ${contract.name}Interface;\n    }\n    static connect(id: string, walletOrProvider: Wallet | Provider): ${contract.name} {\n      return new Contract(id, _abi, walletOrProvider) as ${contract.name};\n    }\n  `.trim();\n\n  return { header, body };\n}\n","export const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\n\nexport declare type SvmType =\n  | BoolType\n  | U8intType\n  | U16intType\n  | U32intType\n  | U64intType\n  | ByteType\n  | B256Type\n  | AddressType\n  | StringType\n  | ArrayType\n  | TupleType\n  | EnumType\n  | StructType\n  | UnknownType;\n\nexport type DatumType = StructType | EnumType | TupleType;\n/**\n * Like SvmType but with void\n */\nexport declare type SvmOutputType = SvmType | VoidType;\n\nexport declare type BoolType = {\n  type: 'bool';\n  originalType: string;\n};\nexport declare type U8intType = {\n  type: 'u8';\n  bits: 8;\n  originalType: string;\n};\nexport declare type U16intType = {\n  type: 'u16';\n  bits: 16;\n  originalType: string;\n};\nexport declare type U32intType = {\n  type: 'u32';\n  bits: 32;\n  originalType: string;\n};\nexport declare type U64intType = {\n  type: 'u64';\n  bits: 64;\n  originalType: string;\n};\nexport declare type ByteType = {\n  type: 'byte';\n  size: 1;\n  originalType: string;\n};\nexport declare type B256Type = {\n  type: 'b256';\n  originalType: string;\n};\nexport declare type AddressType = {\n  type: 'address';\n  originalType: string;\n};\nexport declare type StringType = {\n  type: 'string';\n  size: number;\n  originalType: string;\n};\nexport declare type ArrayType = {\n  type: 'array';\n  itemType: SvmType;\n  size?: number;\n  originalType: string;\n};\nexport declare type TupleType = {\n  type: 'tuple';\n  structName: string;\n  components: SvmSymbol[];\n  originalType: string;\n};\nexport declare type EnumType = {\n  type: 'enum';\n  structName: string;\n  components: SvmSymbol[];\n  originalType: string;\n};\nexport declare type StructType = {\n  type: 'struct';\n  structName: string;\n  components: SvmSymbol[];\n  originalType: string;\n};\n\nexport declare type UnknownType = {\n  type: 'unknown';\n  originalType: string;\n};\n\nexport declare type VoidType = {\n  type: 'void';\n};\n\nexport declare type SvmSymbol = {\n  type: SvmType;\n  name: string;\n};\n\n/**\n * Converts valid file names to valid javascript symbols and does best effort to make them readable.\n * Example: ds-token.test becomes DsTokenTest\n */\nexport function normalizeName(rawName: string): string {\n  const transformations: ((s: string) => string)[] = [\n    (s) => s.replace(/\\s+/g, '-'), // spaces to - so later we can automatically convert them\n    (s) => s.replace(/\\./g, '-'), // replace \".\"\n    (s) => s.replace(/_/g, '-'), // replace \"_\"\n    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them\n    (s) => s.replace(/-/g, ''), // delete any '-' left\n    (s) => s.replace(/^\\d+/, ''), // removes leading digits\n    (s) => s.charAt(0).toUpperCase() + s.slice(1),\n  ];\n\n  const finalName = transformations.reduce((s, t) => t(s), rawName);\n\n  if (finalName === '') {\n    throw new Error(`Can't guess class name, please rename file: ${rawName}`);\n  }\n\n  return finalName;\n}\n\n/**\n * Parses the SvmType from the JSON ABI; recusively on non-primatives\n */\nexport function parseSvmType(rawType: string, components?: SvmSymbol[], name?: string): SvmType {\n  const stringMatch = rawType.match(stringRegEx);\n  if (stringMatch !== null) {\n    const length = stringMatch[1];\n\n    return {\n      type: 'string',\n      size: parseInt(length, 10),\n      originalType: rawType,\n    };\n  }\n\n  const arrayMatch = rawType.match(arrayRegEx);\n  if (arrayMatch !== null) {\n    const type = arrayMatch[1];\n    const length = arrayMatch[2];\n    return {\n      type: 'array',\n      itemType: parseSvmType(type, components),\n      size: parseInt(length, 10),\n      originalType: rawType,\n    };\n  }\n\n  // If type starts with struct/enum we can treat it as tuple.\n  // In this way, the parser can process all components from the struct.\n  const structMatch = structRegEx.exec(rawType)?.groups;\n  if (structMatch) {\n    if (!components) throw new Error(`${rawType} specified without components!`);\n    return {\n      type: 'struct',\n      components,\n      originalType: rawType,\n      structName: structMatch.name,\n    };\n  }\n\n  const enumMatch = enumRegEx.exec(rawType)?.groups;\n  if (enumMatch) {\n    if (!components) throw new Error(`${rawType} specified without components!`);\n    return {\n      type: 'enum',\n      components,\n      originalType: rawType,\n      structName: enumMatch.name,\n    };\n  }\n\n  const tupleMatch = tupleRegEx.exec(rawType)?.groups;\n  if (tupleMatch) {\n    if (!components) throw new Error(`${rawType} specified without components!`);\n    return {\n      type: 'tuple',\n      components,\n      originalType: rawType,\n      structName: normalizeName(name || ''),\n    };\n  }\n\n  switch (rawType) {\n    case 'u8':\n      return { type: 'u8', bits: 8, originalType: rawType };\n    case 'u16':\n      return { type: 'u16', bits: 16, originalType: rawType };\n    case 'u32':\n      return { type: 'u32', bits: 32, originalType: rawType };\n    case 'u64':\n      return { type: 'u64', bits: 64, originalType: rawType };\n    case 'bool':\n      return { type: 'bool', originalType: rawType };\n    case 'address':\n      return { type: 'address', originalType: rawType };\n    case 'b256':\n      return { type: 'b256', originalType: rawType };\n    case 'byte':\n      return { type: 'byte', size: 1, originalType: rawType };\n    default:\n  }\n\n  return { type: 'unknown', originalType: rawType };\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { Dictionary } from 'ts-essentials';\n\nimport type {\n  EnumType,\n  SvmOutputType,\n  SvmType,\n  TupleType,\n  StructType,\n  DatumType,\n} from './parseSvmTypes';\nimport { parseSvmType, normalizeName } from './parseSvmTypes';\n\nexport interface AbiParameter {\n  name: string;\n  type: SvmType;\n}\nexport interface AbiOutputParameter {\n  name: string;\n  type: SvmOutputType;\n  components?: AbiOutputParameter[];\n}\nexport declare type Named<T> = {\n  name: string;\n  values: T;\n};\nexport interface FunctionDocumentation {\n  author?: string;\n  details?: string;\n  notice?: string;\n  params?: { [paramName: string]: string };\n  return?: string;\n}\nexport interface FunctionDeclaration {\n  name: string;\n  inputs: AbiParameter[];\n  outputs: AbiOutputParameter[];\n  documentation?: FunctionDocumentation;\n}\nexport interface FunctionWithoutOutputDeclaration extends FunctionDeclaration {\n  outputs: [];\n}\nexport interface FunctionWithoutInputDeclaration extends FunctionDeclaration {\n  inputs: [];\n}\nexport interface Contract {\n  name: string;\n  rawName: string;\n  functions: Dictionary<FunctionDeclaration[]>;\n  structs: Dictionary<StructType[]>;\n  tuples: Dictionary<TupleType[]>;\n  enums: Dictionary<EnumType[]>;\n  documentation?: {\n    author?: string;\n    details?: string;\n    notice?: string;\n  };\n}\n\nexport interface RawAbiParameter {\n  name: string;\n  type: string;\n  components?: RawAbiParameter[];\n}\n\nexport interface RawAbiDefinition {\n  name: string;\n  inputs: RawAbiParameter[];\n  outputs: RawAbiParameter[];\n  type: string;\n}\nexport interface DocumentationResult {\n  author?: string;\n  details?: string;\n  notice?: string;\n  title?: string;\n  methods?: { [methodName: string]: FunctionDocumentation };\n}\n\n/**\n * Parses the ABI function declaration\n */\nfunction parseFunctionDeclaration(\n  abiPiece: RawAbiDefinition,\n  registerStruct: (datum: DatumType) => void,\n  documentation?: DocumentationResult\n): FunctionDeclaration {\n  return {\n    name: abiPiece.name,\n    inputs: parseInputs(registerStruct, abiPiece.inputs),\n    outputs: parseOutputs(registerStruct, abiPiece.outputs),\n    documentation: getFunctionDocumentation(abiPiece, documentation),\n  };\n}\n\n/**\n * Parses the ABI parameters\n */\nfunction parseRawAbiParameter(\n  rawAbiParameter: RawAbiParameter,\n  registerStruct: (datum: DatumType) => void\n): AbiParameter {\n  return {\n    name: rawAbiParameter.name,\n    type: parseRawAbiParameterType(rawAbiParameter, registerStruct),\n  };\n}\n\n/**\n * Parses the ABI parameter types\n */\nfunction parseRawAbiParameterType(\n  rawAbiParameter: RawAbiParameter,\n  registerStruct: (datum: DatumType) => void\n): SvmType {\n  const components =\n    rawAbiParameter.components &&\n    rawAbiParameter.components.map((component) => ({\n      name: component.name,\n      type: parseRawAbiParameterType(component, registerStruct),\n    }));\n\n  const parsed = parseSvmType(rawAbiParameter.type, components, rawAbiParameter.name);\n  switch (parsed.type) {\n    case 'struct':\n      registerStruct(parsed as StructType);\n      break;\n    case 'tuple':\n      registerStruct(parsed as TupleType);\n      break;\n    case 'enum':\n      registerStruct(parsed as EnumType);\n      break;\n    default:\n      break;\n  }\n  return parsed;\n}\n\n/**\n * Parses the ABI function inputs\n */\nfunction parseInputs(\n  registerStruct: (datum: DatumType) => void,\n  inputs?: Array<RawAbiParameter>\n): AbiParameter[] {\n  return (inputs || [])\n    .filter((i) => i.type !== '()')\n    .map((e) => parseRawAbiParameter(e, registerStruct));\n}\n/**\n * Parses the ABI function outputs\n */\nfunction parseOutputs(\n  registerStruct: (datum: DatumType) => void,\n  outputs?: Array<RawAbiParameter>\n): AbiOutputParameter[] {\n  if (!outputs || outputs.length === 0) {\n    return [{ name: '', type: { type: 'void' } }];\n  }\n\n  return outputs.filter((i) => i.type !== '()').map((e) => parseRawAbiParameter(e, registerStruct));\n}\n/**\n * Parses the JSON abi\n */\nexport function parse(\n  abi: RawAbiDefinition[],\n  rawName: string,\n  documentation?: DocumentationResult\n): Contract {\n  const functions: FunctionDeclaration[] = [];\n\n  const outputs: { struct: StructType[]; enum: EnumType[]; tuple: TupleType[] } = {\n    struct: [],\n    enum: [],\n    tuple: [],\n  };\n\n  /**\n   * Registers Structs used in the abi\n   */\n  function registerComplexType(datum: DatumType): void {\n    if (\n      ['struct', 'enum', 'tuple'].includes(datum.type) &&\n      outputs[datum.type].findIndex((s) => s.structName === datum.structName) === -1\n    ) {\n      (outputs[datum.type] as Array<typeof datum>).push(datum);\n    }\n  }\n\n  abi.forEach((abiPiece) => {\n    if (abiPiece.type === 'function') {\n      functions.push(parseFunctionDeclaration(abiPiece, registerComplexType, documentation));\n    }\n  });\n\n  const functionGroup = functions.reduce((memo, value) => {\n    if (Array.isArray(memo[value.name])) {\n      memo[value.name].push(value);\n    } else {\n      memo[value.name] = [value];\n    }\n    return memo;\n  }, {} as Dictionary<FunctionDeclaration[]>);\n\n  const structGroup = outputs.struct.reduce((memo, value) => {\n    if (memo[value.structName]) {\n      memo[value.structName].push(value);\n    } else {\n      memo[value.structName] = [value];\n    }\n    return memo;\n  }, {} as Dictionary<StructType[]>);\n\n  const tupleGroup = outputs.tuple.reduce((memo, value) => {\n    if (memo[value.structName]) {\n      memo[value.structName].push(value);\n    } else {\n      memo[value.structName] = [value];\n    }\n    return memo;\n  }, {} as Dictionary<TupleType[]>);\n\n  const enumGroup = outputs.enum.reduce((memo, value) => {\n    if (memo[value.structName]) {\n      memo[value.structName].push(value);\n    } else {\n      memo[value.structName] = [value];\n    }\n    return memo;\n  }, {} as Dictionary<EnumType[]>);\n\n  return {\n    name: normalizeName(rawName),\n    rawName,\n    functions: functionGroup,\n    structs: structGroup,\n    tuples: tupleGroup,\n    enums: enumGroup,\n  };\n}\n\n/**\n * Parses the ABI function documentation\n */\nexport function getFunctionDocumentation(\n  abiPiece: RawAbiDefinition,\n  documentation?: DocumentationResult\n): FunctionDocumentation | undefined {\n  const docKey = `${abiPiece.name}(${(abiPiece.inputs || []).map(({ type }) => type).join(',')})`;\n  return documentation && documentation.methods && documentation.methods[docKey];\n}\n\nclass MalformedAbiError extends Error {}\n\n/**\n * Extract JSON abi from raw json strings\n */\nexport function extractAbi(rawJson: string): RawAbiDefinition[] {\n  let json;\n  try {\n    json = JSON.parse(rawJson);\n  } catch {\n    throw new MalformedAbiError('Not a json');\n  }\n\n  if (!json) {\n    throw new MalformedAbiError('Not a json');\n  }\n\n  if (Array.isArray(json)) {\n    return json;\n  }\n\n  if (Array.isArray(json.abi)) {\n    return json.abi;\n  }\n  if (json.compilerOutput && Array.isArray(json.compilerOutput.abi)) {\n    return json.compilerOutput.abi;\n  }\n\n  throw new MalformedAbiError('Not a valid ABI');\n}\n/**\n * Parses the ABI function function documentation to user docs\n */\nexport function extractDocumentation(rawContents: string): DocumentationResult | undefined {\n  let json;\n  try {\n    json = JSON.parse(rawContents);\n  } catch {\n    return undefined;\n  }\n\n  if (!json || (!json.devdoc && !json.userdoc)) return undefined;\n\n  const result: DocumentationResult = json.devdoc || {};\n\n  // Merge devdoc and userdoc objects\n  if (json.userdoc) {\n    result.notice = json.userdoc.notice;\n    if (!json.userdoc.methods) return result;\n    result.methods = result.methods || {};\n    Object.entries<{ notice: string }>(json.userdoc.methods).forEach(([key, { notice }]) => {\n      if (result.methods) result.methods[key] = { ...result.methods[key], notice };\n    });\n  }\n  return result;\n}\n"],"mappings":"+vBAAA,uDACA,MAA6B,cAC7B,EAA8B,gBAG9B,EAA6C,qBCLtC,GAAM,GAAkB,YCE/B,OAA2C,qBCIpC,WAAiC,EAAgC,CACtE,MAAI,GAAS,KAAK,eAAiB,QAAgB,EAAS,KAAK,aAC1D,IAAK,EAAS,KAAmB,WACrC,IAAI,AAAC,GAAM,EAAwB,CAAC,CAAC,EACrC,KAAK,GAAG,IACb,CAKO,WAA2B,EAAiC,CACjE,MAAO,GAAG,EAAG,QAAQ,EAAG,OAAO,IAAI,AAAC,GAAM,EAAwB,CAAC,CAAC,EAAE,KAAK,GAAG,IAChF,CCCO,WACL,EACA,EACQ,CACR,MAAI,GAAM,SAAW,EACZ,GAGF,GAAG,EACP,IACC,CAAC,EAAO,IAAU,GAAG,EAAM,MAAQ,MAAM,QAAY,EAAkB,EAAM,KAAM,CAAO,GAC5F,EACC,KAAK,IAAI,KACd,CAKO,WACL,EACA,EAA+B,CAAC,EACxB,CACR,GAAI,EAAO,SAAW,EAGpB,MAAI,GAAQ,mBACH,EAAQ,mBAEV,OAGT,GAAM,GAAU,EAAO,IAAI,AAAC,GAAW,EAAmB,EAAO,KAAM,CAAO,CAAC,EAE/E,MAAI,GAAQ,OAAS,EACZ,IAAI,EAAQ,KAAK,GAAG,KAGtB,EAAQ,EACjB,CAMO,WAA2B,EAAkB,EAA+B,CAAC,EAAW,CAC7F,OAAQ,EAAQ,UACT,SACA,UACA,UACA,MACH,MAAO,mBACJ,WACA,UACH,MAAO,aACJ,OACH,MAAO,gBACJ,QACH,MAAO,IAAI,MAAM,EAAQ,IAAI,EAC1B,KAAK,EAAkB,EAAQ,SAAU,CAAE,WAAY,EAAK,CAAC,CAAC,EAC9D,KAAK,IAAI,SACT,OACH,MAAO,cACJ,SACH,MAAO,aACJ,QACH,MAAO,GAAkB,EAAS,AAAC,GACjC,EAAkB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC7D,MACG,OACH,MAAI,GAAQ,YAAc,EAAQ,WACzB,GAAG,EAAQ,kBAEb,EAAiB,EAAS,AAAC,GAChC,EAAkB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC7D,MACG,SACH,MAAI,GAAQ,YAAc,EAAQ,WACzB,GAAG,EAAQ,kBAEb,EAAmB,EAAS,AAAC,GAClC,EAAkB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC7D,MACG,UACH,MAAO,cAEP,MAAO,MAEb,CAMO,WACL,EACA,EAA+B,CAAC,EACxB,CACR,GAAI,EAAQ,mBACV,MAAO,GAAQ,mBAGjB,OAAQ,EAAQ,UACT,SACA,MACH,MAAO,aACJ,UACA,MACH,MAAO,aACJ,WACA,UACH,MAAO,aACJ,OACH,MAAO,gBACJ,QACH,MAAO,IAAI,MAAM,EAAQ,IAAI,EAC1B,KAAK,EAAmB,EAAQ,SAAU,CAAE,WAAY,EAAK,CAAC,CAAC,EAC/D,KAAK,IAAI,SACT,OACH,MAAO,cACJ,SACH,MAAO,aACJ,QACH,MAAO,GAAkB,EAAS,AAAC,GACjC,EAAmB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC9D,MACG,OACH,MAAI,GAAQ,YAAc,EAAQ,WACzB,GAAG,EAAQ,mBAEb,EAAiB,EAAS,AAAC,GAChC,EAAmB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC9D,MACG,SACH,MAAI,GAAQ,YAAc,EAAQ,WACzB,GAAG,EAAQ,mBAEb,EAAmB,EAAS,AAAC,GAClC,EAAmB,EAAS,OAAK,GAAL,CAAc,WAAY,EAAK,EAAC,CAC9D,MACG,UACH,MAAO,UACJ,OACH,MAAO,eAEP,MAAO,MAEb,CAEO,WACL,EACA,EACQ,CACR,MAAO,IAAI,EAAM,WAAW,IAAI,AAAC,GAAc,EAAU,EAAU,IAAI,CAAC,EAAE,KAAK,IAAI,IACrF,CAEO,WACL,EACA,EACQ,CACR,MAAO,IAAI,EAAO,WACf,IAAI,AAAC,GAAc,GAAG,EAAU,SAAS,EAAU,EAAU,IAAI,GAAG,EACpE,KAAK,IAAI,IACd,CAEO,WAA0B,EAAiB,EAAiD,CACjG,MAAO,YAAY,EAAM,WACtB,IAAI,AAAC,GAAc,GAAG,EAAU,SAAS,EAAU,EAAU,IAAI,GAAG,EACpE,KAAK,IAAI,KACd,CFvKO,WACL,EACA,EACQ,CACR,MAAI,GAAI,SAAW,EACV,EAAiB,EAAS,EAAI,EAAE,EAGlC,GAA8B,EAAS,CAAG,CACnD,CAKO,YACL,EACA,EACQ,CACR,MAAO,GAAI,IAAI,AAAC,GAAO,EAAiB,EAAS,EAAI,IAAI,EAAkB,CAAE,IAAI,CAAC,EAAE,KAAK;AAAA,CAAI,CAC/F,CAKA,WACE,EACA,EACA,EACQ,CACR,GAAI,GACA,EACJ,MAAI,GAAQ,cACV,GAAe,gCACf,EAAa,gBAEb,GAAe,8DACf,EAAa,WAAW,EAAoB,EAAG,QAAS,CACtD,mBAAoB,EAAQ,mBAC5B,WAAY,EACd,CAAC,MAEI;AAAA,IACL,GAA8B,EAAG,aAAa;AAAA,IAC9C,UAAkB,EAAG,QAAQ,EAAmB,EAAG,OAAQ,CAC3D,WAAY,EACd,CAAC,IAAI,OAAkB;AAAA,CAEzB,CAKA,YAAuC,EAAqC,CAC1E,GAAI,CAAC,EAAK,MAAO,GAEjB,GAAI,GAAY,MAChB,AAAI,EAAI,SAAS,IAAa;AAAA,KAAQ,EAAI,WACtC,EAAI,QAAQ,IAAa;AAAA,KAAQ,EAAI,UAEzC,GAAM,GAAS,OAAO,QAAQ,EAAI,QAAU,CAAC,CAAC,EAC9C,MAAI,GAAO,QACT,EAAO,QAAQ,CAAC,CAAC,EAAK,KAAW,CAC/B,GAAa;AAAA,YAAe,KAAO,GACrC,CAAC,EAGC,EAAI,QAAQ,IAAa;AAAA,cAAiB,EAAI,UAElD,GAAa;AAAA,KAEN,CACT,CAKO,WAA8C,EAAiC,CACpF,MAAO,IAAI,EAAG,0BAChB,CAKO,WAA4C,EAAiC,CAClF,GAAM,GAAe,CAAC,sBAAsB,EAAG,OAAO,EAEtD,MAAI,GAAG,OAAO,OACZ,EAAa,KACX,YAAY,EAAG,OACZ,IAAI,AAAC,GAAU,EAAkB,EAAM,KAAM,CAAE,WAAY,EAAK,CAAC,CAAC,EAClE,KAAK,IAAI,IACd,EAEA,EAAa,KAAK,oBAAoB,EAGjC,sBAAsB,EAAa,KAAK,IAAI,iBACrD,CAKO,WAA4C,EAAiC,CAClF,MAAO,yCAAyC,EAAG,wCACrD,CG5HO,GAAM,GAAmB,GAAI,KAAI,CACtC,SACA,WACA,oBACA,WACA,WACA,SACF,CAAC,ECAc,WAAwB,EAA0B,CAC/D,MAAI,GAAM,WACD;AAAA,oBACS,EAAM,qBAAqB,EAAkB,EAAO,CAClE,WAAY,EACd,CAAC;AAAA;AAAA,oBAEe,EAAM,sBAAsB,EAAmB,EAAO,CACpE,WAAY,EACd,CAAC;AAAA,QAGI,EACT,CCFO,WAAgC,EAAoB,EAAsC,CAkG/F,MAjGiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBf,OAAO,OAAO,EAAS,OAAO,EAC7B,IAAI,AAAC,GAAM,EAAe,EAAE,EAAE,CAAC,EAC/B,KAAK;AAAA,CAAI;AAAA;AAAA,IAEV,OAAO,OAAO,EAAS,KAAK,EAC3B,IAAI,AAAC,GAAM,EAAe,EAAE,EAAE,CAAC,EAC/B,KAAK;AAAA,CAAI;AAAA;AAAA,cAEA,EAAS;AAAA;AAAA,QAEf,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,AAAC,GAAM,EAAE,EAAE,EACf,IAAI,CAAoC,EACxC,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,MAGZ,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,AAAC,GAAM,EAAE,EAAE,EACf,IAAI,CAAkC,EACtC,KAAK;AAAA,CAAI;AAAA;AAAA,MAEV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,AAAC,GAAM,EAAE,EAAE,EACf,IAAI,CAAkC,EACtC,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,iBAGC,EAAS;AAAA,iBACT,EAAS;AAAA;AAAA,QAElB,OAAO,OAAO,EAAS,SAAS,EAC/B,IACC,EAAiB,KAAK,KAAM,CAC1B,cAAe,GACf,eACF,CAAC,CACH,EACC,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,EAAiB,KAAK,KAAM,CAAE,mBAAoB,OAAW,eAAc,CAAC,CAAC,EACjF,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IACC,EAAiB,KAAK,KAAM,CAC1B,mBAAoB,yBACpB,eACF,CAAC,CACH,EACC,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,EAAiB,KAAK,KAAM,CAAE,mBAAoB,OAAW,eAAc,CAAC,CAAC,EACjF,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,EAAiB,KAAK,KAAM,CAAE,mBAAoB,aAAc,eAAc,CAAC,CAAC,EACpF,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,EAAiB,KAAK,KAAM,CAAE,mBAAoB,OAAW,eAAc,CAAC,CAAC,EACjF,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,QAGV,OAAO,OAAO,EAAS,SAAS,EAC/B,IAAI,EAAiB,KAAK,KAAM,CAAE,mBAAoB,aAAc,eAAc,CAAC,CAAC,EACpF,KAAK;AAAA,CAAI;AAAA;AAAA;AAAA,MAGZ,OAAO,OAAO,EAAS,SAAS,EAC/B,OAAO,AAAC,GAAM,CAAC,EAAiB,IAAI,EAAE,GAAG,IAAI,CAAC,EAC9C,IAAI,EAAiB,KAAK,KAAM,CAAE,eAAc,CAAC,CAAC,EAClD,KAAK;AAAA,CAAI;AAAA,IAIhB,CAKO,WACL,EACA,EACQ,CACR,GAAM,CAAE,OAAM,UAAW,GAA6B,EAAU,CAAG,EACnE,MAAO;AAAA,IACL;AAAA;AAAA,iBAEa,EAAS,OAAO;AAAA,MAC3B;AAAA;AAAA,GAGN,CAKA,YACE,EACA,EACkC,CAClC,GAAM,GAAS;AAAA;AAAA;AAAA,kBAGC,EAAS,SAAS,EAAS,4BAA4B,EAAS;AAAA,iBACjE,KAAK,UAAU,EAAK,KAAM,CAAC;AAAA,IACxC,KAAK,EAED,EAAO;AAAA;AAAA,gCAEiB,EAAS;AAAA,sCACH,EAAS;AAAA;AAAA,uEAEwB,EAAS;AAAA,2DACrB,EAAS;AAAA;AAAA,IAEhE,KAAK,EAEP,MAAO,CAAE,SAAQ,MAAK,CACxB,CCjKO,GAAM,IAAc,2BACd,GAAa,4CACb,GAAc,wBACd,GAAY,sBACZ,GAAa,qBA6GnB,WAAuB,EAAyB,CAWrD,GAAM,GAAY,AAViC,CACjD,AAAC,GAAM,EAAE,QAAQ,OAAQ,GAAG,EAC5B,AAAC,GAAM,EAAE,QAAQ,MAAO,GAAG,EAC3B,AAAC,GAAM,EAAE,QAAQ,KAAM,GAAG,EAC1B,AAAC,GAAM,EAAE,QAAQ,UAAW,AAAC,GAAU,EAAM,OAAO,EAAE,EAAE,YAAY,CAAC,EACrE,AAAC,GAAM,EAAE,QAAQ,KAAM,EAAE,EACzB,AAAC,GAAM,EAAE,QAAQ,OAAQ,EAAE,EAC3B,AAAC,GAAM,EAAE,OAAO,CAAC,EAAE,YAAY,EAAI,EAAE,MAAM,CAAC,CAC9C,EAEkC,OAAO,CAAC,EAAG,IAAM,EAAE,CAAC,EAAG,CAAO,EAEhE,GAAI,IAAc,GAChB,KAAM,IAAI,OAAM,+CAA+C,GAAS,EAG1E,MAAO,EACT,CAKO,WAAsB,EAAiB,EAA0B,EAAwB,CAxIhG,UAyIE,GAAM,GAAc,EAAQ,MAAM,EAAW,EAC7C,GAAI,IAAgB,KAAM,CACxB,GAAM,GAAS,EAAY,GAE3B,MAAO,CACL,KAAM,SACN,KAAM,SAAS,EAAQ,EAAE,EACzB,aAAc,CAChB,CACF,CAEA,GAAM,GAAa,EAAQ,MAAM,EAAU,EAC3C,GAAI,IAAe,KAAM,CACvB,GAAM,GAAO,EAAW,GAClB,EAAS,EAAW,GAC1B,MAAO,CACL,KAAM,QACN,SAAU,EAAa,EAAM,CAAU,EACvC,KAAM,SAAS,EAAQ,EAAE,EACzB,aAAc,CAChB,CACF,CAIA,GAAM,GAAc,MAAY,KAAK,CAAO,IAAxB,cAA2B,OAC/C,GAAI,EAAa,CACf,GAAI,CAAC,EAAY,KAAM,IAAI,OAAM,GAAG,iCAAuC,EAC3E,MAAO,CACL,KAAM,SACN,aACA,aAAc,EACd,WAAY,EAAY,IAC1B,CACF,CAEA,GAAM,GAAY,MAAU,KAAK,CAAO,IAAtB,cAAyB,OAC3C,GAAI,EAAW,CACb,GAAI,CAAC,EAAY,KAAM,IAAI,OAAM,GAAG,iCAAuC,EAC3E,MAAO,CACL,KAAM,OACN,aACA,aAAc,EACd,WAAY,EAAU,IACxB,CACF,CAGA,GADmB,MAAW,KAAK,CAAO,IAAvB,cAA0B,OAC7B,CACd,GAAI,CAAC,EAAY,KAAM,IAAI,OAAM,GAAG,iCAAuC,EAC3E,MAAO,CACL,KAAM,QACN,aACA,aAAc,EACd,WAAY,EAAc,GAAQ,EAAE,CACtC,CACF,CAEA,OAAQ,OACD,KACH,MAAO,CAAE,KAAM,KAAM,KAAM,EAAG,aAAc,CAAQ,MACjD,MACH,MAAO,CAAE,KAAM,MAAO,KAAM,GAAI,aAAc,CAAQ,MACnD,MACH,MAAO,CAAE,KAAM,MAAO,KAAM,GAAI,aAAc,CAAQ,MACnD,MACH,MAAO,CAAE,KAAM,MAAO,KAAM,GAAI,aAAc,CAAQ,MACnD,OACH,MAAO,CAAE,KAAM,OAAQ,aAAc,CAAQ,MAC1C,UACH,MAAO,CAAE,KAAM,UAAW,aAAc,CAAQ,MAC7C,OACH,MAAO,CAAE,KAAM,OAAQ,aAAc,CAAQ,MAC1C,OACH,MAAO,CAAE,KAAM,OAAQ,KAAM,EAAG,aAAc,CAAQ,WAI1D,MAAO,CAAE,KAAM,UAAW,aAAc,CAAQ,CAClD,CCrIA,YACE,EACA,EACA,EACqB,CACrB,MAAO,CACL,KAAM,EAAS,KACf,OAAQ,GAAY,EAAgB,EAAS,MAAM,EACnD,QAAS,GAAa,EAAgB,EAAS,OAAO,EACtD,cAAe,GAAyB,EAAU,CAAa,CACjE,CACF,CAKA,WACE,EACA,EACc,CACd,MAAO,CACL,KAAM,EAAgB,KACtB,KAAM,EAAyB,EAAiB,CAAc,CAChE,CACF,CAKA,WACE,EACA,EACS,CACT,GAAM,GACJ,EAAgB,YAChB,EAAgB,WAAW,IAAI,AAAC,GAAe,EAC7C,KAAM,EAAU,KAChB,KAAM,EAAyB,EAAW,CAAc,CAC1D,EAAE,EAEE,EAAS,EAAa,EAAgB,KAAM,EAAY,EAAgB,IAAI,EAClF,OAAQ,EAAO,UACR,SACH,EAAe,CAAoB,EACnC,UACG,QACH,EAAe,CAAmB,EAClC,UACG,OACH,EAAe,CAAkB,EACjC,cAEA,MAEJ,MAAO,EACT,CAKA,YACE,EACA,EACgB,CAChB,MAAQ,IAAU,CAAC,GAChB,OAAO,AAAC,GAAM,EAAE,OAAS,IAAI,EAC7B,IAAI,AAAC,GAAM,EAAqB,EAAG,CAAc,CAAC,CACvD,CAIA,YACE,EACA,EACsB,CACtB,MAAI,CAAC,GAAW,EAAQ,SAAW,EAC1B,CAAC,CAAE,KAAM,GAAI,KAAM,CAAE,KAAM,MAAO,CAAE,CAAC,EAGvC,EAAQ,OAAO,AAAC,GAAM,EAAE,OAAS,IAAI,EAAE,IAAI,AAAC,GAAM,EAAqB,EAAG,CAAc,CAAC,CAClG,CAIO,WACL,EACA,EACA,EACU,CACV,GAAM,GAAmC,CAAC,EAEpC,EAA0E,CAC9E,OAAQ,CAAC,EACT,KAAM,CAAC,EACP,MAAO,CAAC,CACV,EAKA,WAA6B,EAAwB,CACnD,AACE,CAAC,SAAU,OAAQ,OAAO,EAAE,SAAS,EAAM,IAAI,GAC/C,EAAQ,EAAM,MAAM,UAAU,AAAC,GAAM,EAAE,aAAe,EAAM,UAAU,IAAM,IAE3E,EAAQ,EAAM,MAA8B,KAAK,CAAK,CAE3D,CAEA,EAAI,QAAQ,AAAC,GAAa,CACxB,AAAI,EAAS,OAAS,YACpB,EAAU,KAAK,GAAyB,EAAU,EAAqB,CAAa,CAAC,CAEzF,CAAC,EAED,GAAM,GAAgB,EAAU,OAAO,CAAC,EAAM,IAC5C,CAAI,MAAM,QAAQ,EAAK,EAAM,KAAK,EAChC,EAAK,EAAM,MAAM,KAAK,CAAK,EAE3B,EAAK,EAAM,MAAQ,CAAC,CAAK,EAEpB,GACN,CAAC,CAAsC,EAEpC,EAAc,EAAQ,OAAO,OAAO,CAAC,EAAM,IAC/C,CAAI,EAAK,EAAM,YACb,EAAK,EAAM,YAAY,KAAK,CAAK,EAEjC,EAAK,EAAM,YAAc,CAAC,CAAK,EAE1B,GACN,CAAC,CAA6B,EAE3B,EAAa,EAAQ,MAAM,OAAO,CAAC,EAAM,IAC7C,CAAI,EAAK,EAAM,YACb,EAAK,EAAM,YAAY,KAAK,CAAK,EAEjC,EAAK,EAAM,YAAc,CAAC,CAAK,EAE1B,GACN,CAAC,CAA4B,EAE1B,EAAY,EAAQ,KAAK,OAAO,CAAC,EAAM,IAC3C,CAAI,EAAK,EAAM,YACb,EAAK,EAAM,YAAY,KAAK,CAAK,EAEjC,EAAK,EAAM,YAAc,CAAC,CAAK,EAE1B,GACN,CAAC,CAA2B,EAE/B,MAAO,CACL,KAAM,EAAc,CAAO,EAC3B,UACA,UAAW,EACX,QAAS,EACT,OAAQ,EACR,MAAO,CACT,CACF,CAKO,YACL,EACA,EACmC,CACnC,GAAM,GAAS,GAAG,EAAS,QAAS,GAAS,QAAU,CAAC,GAAG,IAAI,CAAC,CAAE,UAAW,CAAI,EAAE,KAAK,GAAG,KAC3F,MAAO,IAAiB,EAAc,SAAW,EAAc,QAAQ,EACzE,CAEA,mBAAgC,MAAM,CAAC,EAKhC,WAAoB,EAAqC,CAC9D,GAAI,GACJ,GAAI,CACF,EAAO,KAAK,MAAM,CAAO,CAC3B,MAAE,CACA,KAAM,IAAI,GAAkB,YAAY,CAC1C,CAEA,GAAI,CAAC,EACH,KAAM,IAAI,GAAkB,YAAY,EAG1C,GAAI,MAAM,QAAQ,CAAI,EACpB,MAAO,GAGT,GAAI,MAAM,QAAQ,EAAK,GAAG,EACxB,MAAO,GAAK,IAEd,GAAI,EAAK,gBAAkB,MAAM,QAAQ,EAAK,eAAe,GAAG,EAC9D,MAAO,GAAK,eAAe,IAG7B,KAAM,IAAI,GAAkB,iBAAiB,CAC/C,CAIO,WAA8B,EAAsD,CACzF,GAAI,GACJ,GAAI,CACF,EAAO,KAAK,MAAM,CAAW,CAC/B,MAAE,CACA,MACF,CAEA,GAAI,CAAC,GAAS,CAAC,EAAK,QAAU,CAAC,EAAK,QAAU,OAE9C,GAAM,GAA8B,EAAK,QAAU,CAAC,EAGpD,GAAI,EAAK,QAAS,CAEhB,GADA,EAAO,OAAS,EAAK,QAAQ,OACzB,CAAC,EAAK,QAAQ,QAAS,MAAO,GAClC,EAAO,QAAU,EAAO,SAAW,CAAC,EACpC,OAAO,QAA4B,EAAK,QAAQ,OAAO,EAAE,QAAQ,CAAC,CAAC,EAAK,CAAE,aAAc,CACtF,AAAI,EAAO,SAAS,GAAO,QAAQ,GAAO,OAAK,EAAO,QAAQ,IAApB,CAA0B,QAAO,GAC7E,CAAC,CACH,CACA,MAAO,EACT,CTzSA,GAAM,IAAmB,2BAEzB,eAAmC,kBAAgB,CAajD,YAAY,EAAgB,CAC1B,MAAM,CAAM,EAbd,UAAO,QAIU,mBAMb,CAAC,EAKH,GAAM,CAAE,MAAK,SAAQ,YAAa,EAElC,KAAK,UAAY,cAAQ,EAAK,GAAU,EAAgB,EAExD,KAAK,aAAe,EAAS,IAAI,AAAC,GAAO,EAAc,kBAAY,CAAE,CAAC,CAAC,CACzE,CAEA,cAAc,EAAiD,CAC7D,GAAM,GAAO,kBAAY,EAAK,IAAI,EAC5B,EAAM,EAAW,EAAK,QAAQ,EAEpC,GAAI,EAAI,SAAW,EACjB,OAGF,GAAM,GAAgB,EAAqB,EAAK,QAAQ,EAClD,EAAW,EAAM,EAAK,EAAM,CAAa,EAE/C,YAAK,cAAc,GAAQ,CAAE,MAAK,UAAS,EACpC,CAAC,KAAK,uBAAuB,EAAU,KAAK,IAAI,KAAK,CAAC,CAC/D,CAEA,uBAAuB,EAAoB,EAA+C,CACxF,MAAO,CACL,KAAM,WAAK,KAAK,UAAW,GAAG,EAAS,WAAW,EAClD,SAAU,EAAuB,EAAU,CAAa,CAC1D,CACF,CAEA,UAA8B,CAuB5B,MAXiB,CACf,GAV2B,OAAO,KAAK,KAAK,aAAa,EAAE,IAAI,AAAC,GAAiB,CAEjF,GAAM,CAAE,WAAU,OAAQ,KAAK,cAAc,GAC7C,MAAO,CACL,KAAM,WAAK,KAAK,UAAW,YAAa,GAAG,EAAS,OAAO,MAAoB,EAC/E,SAAU,EAA+B,EAAU,CAAG,CACxD,CACF,CAAC,EAIC,CACE,KAAM,WAAK,KAAK,UAAW,aAAa,EACxC,SAAU,mBAAa,WAAK,UAAW,uBAAuB,EAAG,OAAO,CAC1E,EACA,CACE,KAAM,WAAK,KAAK,UAAW,UAAU,EACrC,SAAU,KAAK,aAAa,CAC9B,CACF,EAAE,OAAO,OAAO,CAElB,CAEQ,cAAuB,CAC7B,GAAM,GAAoB,CAAC,EAErB,EAA2B,GAAI,KAAI,KAAK,YAAY,EAE1D,OAAW,KAAY,GAA0B,CAC/C,GAAM,GAAgB,EAEtB,EAAQ,KAAK,iBAAiB,eAA2B,IAAgB,CAC3E,CAEA,EAAQ,KAAK;AAAA,CAAI,EAGjB,OAAW,KAAY,GAA0B,CAC/C,GAAM,GAAgB,GAAG,aAEzB,EAAQ,KAAK,YAAY,yBAAqC,IAAgB,CAChF,CAEA,MAAO,GAAQ,KAAK;AAAA,CAAI,CAC1B,CACF","names":[]}