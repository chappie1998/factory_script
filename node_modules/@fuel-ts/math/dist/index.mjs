import b from"bn.js";var B=3,f=1,d=9;function I(o,t){let{precision:r=3,minPrecision:e=1}=t||{},[i="0",u="0"]=String(o||"0.0").split("."),p=/(\d)(?=(\d{3})+\b)/g,m=i.replace(p,"$1,"),a=u.slice(0,r);if(e<r){let c=a.match(/[1-9]/),y=(c==null?void 0:c.index)==null?-1:c.index,h=Math.max(e,y+1);a=a.slice(0,h)}let g=a?`.${a}`:"";return`${m}${g}`}var n=class extends b{constructor(t,r,e){if(n.isBN(t)){super(t.toArray(),r,e);return}if(typeof t=="string"&&t.slice(0,2)==="0x"){super(t.substring(2),r||"hex",e);return}let i=t==null?0:t;super(i,r,e)}toString(t,r){let e=super.toString(t,r);return t===16||t==="hex"?`0x${e}`:e}toHex(t){let e=(t||0)*2;if(this.isNeg())throw new Error("cannot convert negative value to hex");if(t&&this.byteLength()>t)throw new Error(`value ${this} exceeds bytes ${t}`);return this.toString(16,e)}toBytes(t){if(this.isNeg())throw new Error("cannot convert negative value to Bytes");return Uint8Array.from(this.toArray(void 0,t))}toJSON(){return this.toString(16)}format(t){let{units:r=9,precision:e=3,minPrecision:i=1}=t||{},u=this.formatUnits(r),p=I(u,{precision:e,minPrecision:i});if(!parseFloat(p)){let[,m="0"]=u.split("."),a=m.match(/[1-9]/);if(a&&a.index&&a.index+1>e){let[g="0"]=p.split(".");return`${g}.${m.slice(0,a.index+1)}`}}return p}formatUnits(t=9){let r=this.toString().slice(0,t*-1),e=this.toString().slice(t*-1),i=e.length,u=Array.from({length:t-i}).fill("0").join("");return`${r?`${r}.`:"0."}${u}${e}`}add(t){return this.caller(t,"add")}pow(t){return this.caller(t,"pow")}sub(t){return this.caller(t,"sub")}div(t){return this.caller(t,"div")}mul(t){return this.caller(t,"mul")}mod(t){return this.caller(t,"mod")}divRound(t){return this.caller(t,"divRound")}lt(t){return this.caller(t,"lt")}lte(t){return this.caller(t,"lte")}gt(t){return this.caller(t,"gt")}gte(t){return this.caller(t,"gte")}eq(t){return this.caller(t,"eq")}cmp(t){return this.caller(t,"cmp")}sqr(){return new n(super.sqr().toArray())}neg(){return new n(super.neg().toArray())}abs(){return new n(super.abs().toArray())}toTwos(t){return new n(super.toTwos(t).toArray())}fromTwos(t){return new n(super.fromTwos(t).toArray())}caller(t,r){let e=super[r](new n(t));return n.isBN(e)?new n(e.toArray()):e}clone(){return new n(this.toArray())}mulTo(t,r){let e=new b(this.toArray()).mulTo(t,r);return new n(e.toArray())}egcd(t){let{a:r,b:e,gcd:i}=new b(this.toArray()).egcd(t);return{a:new n(r.toArray()),b:new n(e.toArray()),gcd:new n(i.toArray())}}divmod(t,r,e){let{div:i,mod:u}=new b(this.toArray()).divmod(new n(t),r,e);return{div:new n(i==null?void 0:i.toArray()),mod:new n(u==null?void 0:u.toArray())}}},s=(o,t,r)=>new n(o,t,r);s.parseUnits=(o,t=9)=>{let r=o==="."?"0.":o,[e="0",i="0"]=r.split("."),u=i.length;if(u>t)throw new Error("Decimal can't be bigger than the units");let p=Array.from({length:t}).fill("0");p.splice(0,u,i);let m=`${e.replace(",","")}${p.join("")}`;return s(m)};function F(o){return s(o).toNumber()}function R(o,t){return s(o).toHex(t)}function S(o,t){return s(o).toBytes(t)}function O(o,t){return s(o).formatUnits(t)}function $(o,t){return s(o).format(t)}function L(...o){return o.reduce((t,r)=>s(r).gt(t)?s(r):t,s(0))}function H(...o){return s(Math.ceil(o.reduce((t,r)=>s(t).mul(r),s(1)).toNumber()))}export{n as BN,d as DECIMAL_UNITS,f as DEFAULT_MIN_PRECISION,B as DEFAULT_PRECISION,s as bn,$ as format,O as formatUnits,L as max,H as multiply,S as toBytes,I as toFixed,R as toHex,F as toNumber};
//# sourceMappingURL=index.mjs.map